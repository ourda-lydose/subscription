package id.ac.ui.cs.advprog.subscription.service.implementations;import id.ac.ui.cs.advprog.subscription.domains.entities.Subscription;import id.ac.ui.cs.advprog.subscription.domains.models.SubscriptionData;import id.ac.ui.cs.advprog.subscription.domains.models.responses.ResponseData;import id.ac.ui.cs.advprog.subscription.repository.SubscriptionRepository;import id.ac.ui.cs.advprog.subscription.service.interfaces.SubscriptionService;import lombok.RequiredArgsConstructor;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import org.springframework.web.server.ResponseStatusException;import java.time.LocalDate;import java.time.ZoneId;import java.util.*;import java.util.logging.Logger;@Service@RequiredArgsConstructorpublic class SubscriptionServiceImpl implements SubscriptionService {    private static final Logger logger = Logger.getLogger(SubscriptionService.class.getName());    private final RestTemplate restTemplate;    private final SubscriptionRepository subscriptionRepository;    @Override    public ResponseEntity<List<Subscription>> getSubscriptions(){        try {            return new ResponseEntity<>(subscriptionRepository.findAll(), HttpStatus.OK);        }        catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<Subscription> getSubscriptionById(String subscription_id) {        try {            String id = subscription_id.substring(4);            Optional<Subscription> subscriptionOptional = subscriptionRepository.findById(id);            if(subscriptionOptional.isEmpty()){                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Subscription with ID: " + subscription_id + " not found");            }            String uniqueCode = subscriptionOptional.get().getCode().substring(0,3);            System.out.println(uniqueCode);            System.out.println(subscription_id.substring(0,3));            if(!subscription_id.substring(0,3).equals(uniqueCode)){                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Subscription with ID: " + subscription_id + " not found");            }            return new ResponseEntity<>(subscriptionOptional.get(), HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<Subscription> createSubscription(SubscriptionData subscriptionData) {        try {            UUID uuid = UUID.randomUUID();            Subscription subscription = new Subscription();            subscription.setId(uuid.toString());            subscription.setType(subscriptionData.getType());            subscription.setStatusString("PENDING");            subscription.setSubscriptionBox(subscriptionData.getSubscriptionBox());            int subs_month = switch (subscriptionData.getType()) {                case MONTHLY -> {                    subscription.setCode("MTH-" + uuid);                    yield 1;                }                case QUARTERLY -> {                    subscription.setCode("QTR-" + uuid);                    yield 4;                }                case SEMI_ANNUAL -> {                    subscription.setCode("SAA-" + uuid);                    yield 6;                }            };            // FOR AUTOMATIC SET START DATE//            subscription.setStartDate(LocalDate.now(ZoneId.of("Asia/Jakarta")));            // FOR MANUAL SET START DATE            subscription.setStartDate(subscriptionData.getStartDate());            subscription.setEndDate(subscription.getStartDate().plusMonths(subs_month));            subscriptionRepository.save(subscription);            return new ResponseEntity<>(subscription, HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<ResponseData<Subscription>> updateSubscription(String subscription_id, SubscriptionData subscriptionData) {        try {            Subscription subscription = getSubscriptionById(subscription_id).getBody();            String subs_id = subscription.getId();            int subs_month = switch (subscriptionData.getType()) {                case MONTHLY -> {                    subscription.setCode("MTH-" + subs_id);                    yield 1;                }                case QUARTERLY -> {                    subscription.setCode("QTR-" + subs_id);                    yield 4;                }                case SEMI_ANNUAL -> {                    subscription.setCode("SAA-" + subs_id);                    yield 6;                }            };            if(subscriptionData.getStatusString() != null){                switch (subscriptionData.getStatusString()){                    case PENDING -> subscription.setStatusString("PENDING");                    case CANCELLED -> subscription.setStatusString("CANCELLED");                    case SUBSCRIBED -> subscription.setStatusString("SUBSCRIBED");                    default -> throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Status is not permissible!");                }            }            subscription.setType(subscriptionData.getType());            subscription.setStartDate(subscriptionData.getStartDate());            subscription.setEndDate(subscriptionData.getStartDate().plusMonths(subs_month));            subscriptionRepository.save(subscription);            return new ResponseEntity<>(new ResponseData<>(subscription, "Subscription updated successfully!"), HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<String> deleteSubscriptionById(String subscription_id) {        try {            Subscription subscription = getSubscriptionById(subscription_id).getBody();            subscriptionRepository.deleteById(subscription.getId());            return new ResponseEntity<>("Deleted Subscription with ID " + subscription_id, HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<Subscription> cancelSubscriptionById(String subscription_id) {        try {            Subscription subscription = getSubscriptionById(subscription_id).getBody();            assert subscription != null;            subscription.setStatusString("CANCELLED");            subscriptionRepository.save(subscription);            return new ResponseEntity<>(subscription, HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<List<Subscription>> getSubscriptionsByStatus(String statusString) {        try {            List<Subscription> subscriptions = subscriptionRepository.findAll().stream()                    .filter(subscription -> {                        if (statusString == null) {                            return true;                        }                        String subscriptionStatus = subscription.getStatusString();                        return subscriptionStatus != null && subscriptionStatus.equals(statusString);                    })                    .toList();            return new ResponseEntity<>(subscriptions, HttpStatus.OK);        } catch (ResponseStatusException e) {            throw new ResponseStatusException(e.getStatusCode(), e.getReason());        }    }    @Override    public ResponseEntity<List<Subscription>> getSubscriptionHistory(String statusString){        List<Subscription> subscriptions = subscriptionRepository.findAllByEndDateBefore(LocalDate.now(ZoneId.of("Asia/Jakarta")));        if(statusString != null){            List<Subscription> filteredSubscription = new ArrayList<>();            for (Subscription subscription : subscriptions) {                if(subscription.getStatusString().equals(statusString)){                    filteredSubscription.add(subscription);                }            }            return new ResponseEntity<>(filteredSubscription, HttpStatus.OK);        }        return new ResponseEntity<>(subscriptions, HttpStatus.OK);    }}